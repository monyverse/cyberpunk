import {
  PaymentPayloadSchema,
  authorizationTypes,
  getNetworkId,
  isAccount,
  isSignerWallet,
  safeBase64Decode,
  safeBase64Encode
} from "./chunk-7T6MR2TA.mjs";
import {
  __require
} from "./chunk-VZWJMN5K.mjs";

// src/schemes/exact/evm/utils/paymentUtils.ts
function encodePayment(payment) {
  const safe = {
    ...payment,
    payload: {
      ...payment.payload,
      authorization: Object.fromEntries(
        Object.entries(payment.payload.authorization).map(([key, value]) => [
          key,
          typeof value === "bigint" ? value.toString() : value
        ])
      )
    }
  };
  return safeBase64Encode(JSON.stringify(safe));
}
function decodePayment(payment) {
  const decoded = safeBase64Decode(payment);
  const parsed = JSON.parse(decoded);
  const obj = {
    ...parsed,
    payload: {
      signature: parsed.payload.signature,
      authorization: {
        ...parsed.payload.authorization,
        value: parsed.payload.authorization.value,
        validAfter: parsed.payload.authorization.validAfter,
        validBefore: parsed.payload.authorization.validBefore
      }
    }
  };
  const validated = PaymentPayloadSchema.parse(obj);
  return validated;
}

// src/schemes/exact/evm/sign.ts
import { toHex } from "viem";
async function signAuthorization(walletClient, { from, to, value, validAfter, validBefore, nonce }, { asset, network, extra }) {
  const chainId = getNetworkId(network);
  const name = extra?.name;
  const version = extra?.version;
  const account = isSignerWallet(walletClient) ? walletClient.account : walletClient;
  const data = {
    account,
    types: authorizationTypes,
    domain: {
      name,
      version,
      chainId,
      verifyingContract: asset
    },
    primaryType: "TransferWithAuthorization",
    message: {
      from,
      to,
      value,
      validAfter,
      validBefore,
      nonce
    }
  };
  if (isSignerWallet(walletClient)) {
    const signature = await walletClient.signTypedData(data);
    return {
      signature
    };
  } else if (isAccount(walletClient) && walletClient.signTypedData) {
    const signature = await walletClient.signTypedData(data);
    return {
      signature
    };
  } else {
    throw new Error("Invalid wallet client provided does not support signTypedData");
  }
}
function createNonce() {
  const cryptoObj = typeof globalThis.crypto !== "undefined" && typeof globalThis.crypto.getRandomValues === "function" ? globalThis.crypto : (
    // Dynamic require is needed to support node.js
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    __require("crypto").webcrypto
  );
  return toHex(cryptoObj.getRandomValues(new Uint8Array(32)));
}

// src/schemes/exact/evm/client.ts
function preparePaymentHeader(from, x402Version, paymentRequirements) {
  const nonce = createNonce();
  const validAfter = BigInt(
    Math.floor(Date.now() / 1e3) - 600
    // 10 minutes before
  ).toString();
  const validBefore = BigInt(
    Math.floor(Date.now() / 1e3 + paymentRequirements.maxTimeoutSeconds)
  ).toString();
  return {
    x402Version,
    scheme: paymentRequirements.scheme,
    network: paymentRequirements.network,
    payload: {
      signature: void 0,
      authorization: {
        from,
        to: paymentRequirements.payTo,
        value: paymentRequirements.maxAmountRequired,
        validAfter: validAfter.toString(),
        validBefore: validBefore.toString(),
        nonce
      }
    }
  };
}
async function signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader) {
  const { signature } = await signAuthorization(
    client,
    unsignedPaymentHeader.payload.authorization,
    paymentRequirements
  );
  return {
    ...unsignedPaymentHeader,
    payload: {
      ...unsignedPaymentHeader.payload,
      signature
    }
  };
}
async function createPayment(client, x402Version, paymentRequirements) {
  const from = isSignerWallet(client) ? client.account.address : client.address;
  const unsignedPaymentHeader = preparePaymentHeader(from, x402Version, paymentRequirements);
  return signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader);
}
async function createPaymentHeader(client, x402Version, paymentRequirements) {
  const payment = await createPayment(client, x402Version, paymentRequirements);
  return encodePayment(payment);
}

export {
  encodePayment,
  decodePayment,
  preparePaymentHeader,
  signPaymentHeader,
  createPayment,
  createPaymentHeader
};
//# sourceMappingURL=chunk-R5PYRJD2.mjs.map