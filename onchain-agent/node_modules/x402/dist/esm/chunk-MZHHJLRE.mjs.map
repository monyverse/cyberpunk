{"version":3,"sources":["../../src/client/createPaymentHeader.ts","../../src/client/preparePaymentHeader.ts","../../src/client/selectPaymentRequirements.ts","../../src/client/signPaymentHeader.ts"],"sourcesContent":["import { createPaymentHeader as createPaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { SupportedEVMNetworks } from \"../types/shared\";\nimport { SignerWallet } from \"../types/shared/evm\";\nimport { PaymentRequirements } from \"../types/verify\";\n\n/**\n * Creates a payment header based on the provided client and payment requirements.\n * \n * @param client - The signer wallet instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the created payment header string\n */\nexport async function createPaymentHeader(\n  client: SignerWallet,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<string> {\n  if (\n    paymentRequirements.scheme === \"exact\" &&\n    SupportedEVMNetworks.includes(paymentRequirements.network)\n  ) {\n    return await createPaymentHeaderExactEVM(client, x402Version, paymentRequirements);\n  }\n\n  throw new Error(\"Unsupported scheme\");\n}","import { Address } from \"viem\";\nimport { preparePaymentHeader as preparePaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { SupportedEVMNetworks } from \"../types/shared\";\nimport { PaymentRequirements, UnsignedPaymentPayload } from \"../types/verify\";\n\n/**\n * Prepares a payment header with the given sender address and payment requirements.\n * \n * @param from - The sender's address from which the payment will be made\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns An unsigned payment payload that can be used to create a payment header\n */\nexport function preparePaymentHeader(\n  from: Address,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): UnsignedPaymentPayload {\n  if (\n    paymentRequirements.scheme === \"exact\" &&\n    SupportedEVMNetworks.includes(paymentRequirements.network)\n  ) {\n    return preparePaymentHeaderExactEVM(from, x402Version, paymentRequirements);\n  }\n\n  throw new Error(\"Unsupported scheme\");\n}","import { Network, PaymentRequirements } from \"../types\";\nimport { getUsdcAddressForChain } from \"../shared/evm\";\nimport { getNetworkId } from \"../shared/network\";\n\n/**\n * Default selector for payment requirements.\n * Default behavior is to select the first payment requirement that has a USDC asset.\n * If no USDC payment requirement is found, the first payment requirement is selected.\n * \n * @param paymentRequirements - The payment requirements to select from.\n * @param network - The network to check against. If not provided, the network will not be checked.\n * @param scheme - The scheme to check against. If not provided, the scheme will not be checked.\n * @returns The payment requirement that is the most appropriate for the user.\n */\nexport function selectPaymentRequirements(paymentRequirements: PaymentRequirements[], network?: Network, scheme?: \"exact\"): PaymentRequirements {\n  // Sort `base` payment requirements to the front of the list. This is to ensure that base is preferred if available.\n  paymentRequirements.sort((a, b) => {\n    if (a.network === \"base\" && b.network !== \"base\") {\n      return -1;\n    }\n    if (a.network !== \"base\" && b.network === \"base\") {\n      return 1;\n    }\n    return 0;\n  });\n\n  // Filter down to the scheme/network if provided\n  const broadlyAcceptedPaymentRequirements = paymentRequirements.filter(requirement => {\n    // If the scheme is not provided, we accept any scheme.\n    const isExpectedScheme = !scheme || requirement.scheme === scheme;\n    // If the chain is not provided, we accept any chain.\n    const isExpectedChain = !network || network == requirement.network;\n\n    return isExpectedScheme && isExpectedChain;\n  });\n\n  // Filter down to USDC requirements\n  const usdcRequirements = broadlyAcceptedPaymentRequirements.filter(requirement => {\n    // If the address is a USDC address, we return it.\n    return requirement.asset === getUsdcAddressForChain(getNetworkId(requirement.network));\n  });\n\n  // Prioritize USDC requirements if available\n  if (usdcRequirements.length > 0) {\n    return usdcRequirements[0];\n  }\n\n  // If no USDC requirements are found, return the first broadly accepted requirement.\n  if (broadlyAcceptedPaymentRequirements.length > 0) {\n    return broadlyAcceptedPaymentRequirements[0];\n  }\n\n  // If no matching requirements are found, return the first requirement.\n  return paymentRequirements[0];\n}\n\n/**\n * Selector for payment requirements.\n * \n * @param paymentRequirements - The payment requirements to select from.\n * @param network - The network to check against. If not provided, the network will not be checked.\n * @param scheme - The scheme to check against. If not provided, the scheme will not be checked.\n * @returns The payment requirement that is the most appropriate for the user.\n */\nexport type PaymentRequirementsSelector = (paymentRequirements: PaymentRequirements[], network?: Network, scheme?: \"exact\") => PaymentRequirements;\n","import { signPaymentHeader as signPaymentHeaderExactEVM } from \"../schemes/exact/evm/client\";\nimport { encodePayment } from \"../schemes/exact/evm/utils/paymentUtils\";\nimport { SupportedEVMNetworks } from \"../types/shared\";\nimport { SignerWallet } from \"../types/shared/evm\";\nimport { PaymentRequirements, UnsignedPaymentPayload } from \"../types/verify\";\n\n/**\n * Signs a payment header using the provided client and payment requirements.\n * \n * @param client - The signer wallet instance used to sign the payment header\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param unsignedPaymentHeader - The unsigned payment payload to be signed\n * @returns A promise that resolves to the encoded signed payment header string\n */\nexport async function signPaymentHeader(\n  client: SignerWallet,\n  paymentRequirements: PaymentRequirements,\n  unsignedPaymentHeader: UnsignedPaymentPayload,\n): Promise<string> {\n  if (\n    paymentRequirements.scheme === \"exact\" &&\n    SupportedEVMNetworks.includes(paymentRequirements.network)\n  ) {\n    const signedPaymentHeader = await signPaymentHeaderExactEVM(client, paymentRequirements, unsignedPaymentHeader);\n    return encodePayment(signedPaymentHeader);\n  }\n\n  throw new Error(\"Unsupported scheme\");\n}"],"mappings":";;;;;;;;;;;;;;;AAaA,eAAsBA,qBACpB,QACA,aACA,qBACiB;AACjB,MACE,oBAAoB,WAAW,WAC/B,qBAAqB,SAAS,oBAAoB,OAAO,GACzD;AACA,WAAO,MAAM,oBAA4B,QAAQ,aAAa,mBAAmB;AAAA,EACnF;AAEA,QAAM,IAAI,MAAM,oBAAoB;AACtC;;;ACbO,SAASC,sBACd,MACA,aACA,qBACwB;AACxB,MACE,oBAAoB,WAAW,WAC/B,qBAAqB,SAAS,oBAAoB,OAAO,GACzD;AACA,WAAO,qBAA6B,MAAM,aAAa,mBAAmB;AAAA,EAC5E;AAEA,QAAM,IAAI,MAAM,oBAAoB;AACtC;;;ACZO,SAAS,0BAA0B,qBAA4C,SAAmB,QAAuC;AAE9I,sBAAoB,KAAK,CAAC,GAAG,MAAM;AACjC,QAAI,EAAE,YAAY,UAAU,EAAE,YAAY,QAAQ;AAChD,aAAO;AAAA,IACT;AACA,QAAI,EAAE,YAAY,UAAU,EAAE,YAAY,QAAQ;AAChD,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,CAAC;AAGD,QAAM,qCAAqC,oBAAoB,OAAO,iBAAe;AAEnF,UAAM,mBAAmB,CAAC,UAAU,YAAY,WAAW;AAE3D,UAAM,kBAAkB,CAAC,WAAW,WAAW,YAAY;AAE3D,WAAO,oBAAoB;AAAA,EAC7B,CAAC;AAGD,QAAM,mBAAmB,mCAAmC,OAAO,iBAAe;AAEhF,WAAO,YAAY,UAAU,uBAAuB,aAAa,YAAY,OAAO,CAAC;AAAA,EACvF,CAAC;AAGD,MAAI,iBAAiB,SAAS,GAAG;AAC/B,WAAO,iBAAiB,CAAC;AAAA,EAC3B;AAGA,MAAI,mCAAmC,SAAS,GAAG;AACjD,WAAO,mCAAmC,CAAC;AAAA,EAC7C;AAGA,SAAO,oBAAoB,CAAC;AAC9B;;;ACxCA,eAAsBC,mBACpB,QACA,qBACA,uBACiB;AACjB,MACE,oBAAoB,WAAW,WAC/B,qBAAqB,SAAS,oBAAoB,OAAO,GACzD;AACA,UAAM,sBAAsB,MAAM,kBAA0B,QAAQ,qBAAqB,qBAAqB;AAC9G,WAAO,cAAc,mBAAmB;AAAA,EAC1C;AAEA,QAAM,IAAI,MAAM,oBAAoB;AACtC;","names":["createPaymentHeader","preparePaymentHeader","signPaymentHeader"]}