import {
  createPaymentHeader,
  encodePayment,
  preparePaymentHeader,
  signPaymentHeader
} from "./chunk-R5PYRJD2.mjs";
import {
  SupportedEVMNetworks,
  getNetworkId
} from "./chunk-7T6MR2TA.mjs";
import {
  getUsdcAddressForChain
} from "./chunk-VZWJMN5K.mjs";

// src/client/createPaymentHeader.ts
async function createPaymentHeader2(client, x402Version, paymentRequirements) {
  if (paymentRequirements.scheme === "exact" && SupportedEVMNetworks.includes(paymentRequirements.network)) {
    return await createPaymentHeader(client, x402Version, paymentRequirements);
  }
  throw new Error("Unsupported scheme");
}

// src/client/preparePaymentHeader.ts
function preparePaymentHeader2(from, x402Version, paymentRequirements) {
  if (paymentRequirements.scheme === "exact" && SupportedEVMNetworks.includes(paymentRequirements.network)) {
    return preparePaymentHeader(from, x402Version, paymentRequirements);
  }
  throw new Error("Unsupported scheme");
}

// src/client/selectPaymentRequirements.ts
function selectPaymentRequirements(paymentRequirements, network, scheme) {
  paymentRequirements.sort((a, b) => {
    if (a.network === "base" && b.network !== "base") {
      return -1;
    }
    if (a.network !== "base" && b.network === "base") {
      return 1;
    }
    return 0;
  });
  const broadlyAcceptedPaymentRequirements = paymentRequirements.filter((requirement) => {
    const isExpectedScheme = !scheme || requirement.scheme === scheme;
    const isExpectedChain = !network || network == requirement.network;
    return isExpectedScheme && isExpectedChain;
  });
  const usdcRequirements = broadlyAcceptedPaymentRequirements.filter((requirement) => {
    return requirement.asset === getUsdcAddressForChain(getNetworkId(requirement.network));
  });
  if (usdcRequirements.length > 0) {
    return usdcRequirements[0];
  }
  if (broadlyAcceptedPaymentRequirements.length > 0) {
    return broadlyAcceptedPaymentRequirements[0];
  }
  return paymentRequirements[0];
}

// src/client/signPaymentHeader.ts
async function signPaymentHeader2(client, paymentRequirements, unsignedPaymentHeader) {
  if (paymentRequirements.scheme === "exact" && SupportedEVMNetworks.includes(paymentRequirements.network)) {
    const signedPaymentHeader = await signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader);
    return encodePayment(signedPaymentHeader);
  }
  throw new Error("Unsupported scheme");
}

export {
  createPaymentHeader2 as createPaymentHeader,
  preparePaymentHeader2 as preparePaymentHeader,
  selectPaymentRequirements,
  signPaymentHeader2 as signPaymentHeader
};
//# sourceMappingURL=chunk-MZHHJLRE.mjs.map