{"version":3,"sources":["../../src/schemes/exact/evm/utils/paymentUtils.ts","../../src/schemes/exact/evm/sign.ts","../../src/schemes/exact/evm/client.ts"],"sourcesContent":["import { safeBase64Encode, safeBase64Decode } from \"../../../../shared\";\nimport { PaymentPayload, PaymentPayloadSchema } from \"../../../../types/verify\";\n\n/**\n * Encodes a payment payload into a base64 string, ensuring bigint values are properly stringified\n *\n * @param payment - The payment payload to encode\n * @returns A base64 encoded string representation of the payment payload\n */\nexport function encodePayment(payment: PaymentPayload): string {\n  const safe = {\n    ...payment,\n    payload: {\n      ...payment.payload,\n      authorization: Object.fromEntries(\n        Object.entries(payment.payload.authorization).map(([key, value]) => [\n          key,\n          typeof value === \"bigint\" ? (value as bigint).toString() : value,\n        ]),\n      ),\n    },\n  };\n  return safeBase64Encode(JSON.stringify(safe));\n}\n\n/**\n * Decodes a base64 encoded payment string back into a PaymentPayload object\n *\n * @param payment - The base64 encoded payment string to decode\n * @returns The decoded and validated PaymentPayload object\n */\nexport function decodePayment(payment: string): PaymentPayload {\n  const decoded = safeBase64Decode(payment);\n  const parsed = JSON.parse(decoded);\n\n  const obj = {\n    ...parsed,\n    payload: {\n      signature: parsed.payload.signature,\n      authorization: {\n        ...parsed.payload.authorization,\n        value: parsed.payload.authorization.value,\n        validAfter: parsed.payload.authorization.validAfter,\n        validBefore: parsed.payload.authorization.validBefore,\n      },\n    },\n  };\n\n  const validated = PaymentPayloadSchema.parse(obj);\n  return validated;\n}\n","import { Account, Address, Chain, Hex, toHex, Transport } from \"viem\";\nimport { getNetworkId } from \"../../../shared\";\nimport {\n  authorizationTypes,\n  isAccount,\n  isSignerWallet,\n  SignerWallet,\n} from \"../../../types/shared/evm\";\nimport { ExactEvmPayloadAuthorization, PaymentRequirements } from \"../../../types/verify\";\n\n/**\n * Signs an EIP-3009 authorization for USDC transfer\n *\n * @param walletClient - The wallet client that will sign the authorization\n * @param params - The authorization parameters containing transfer details\n * @param params.from - The address tokens will be transferred from\n * @param params.to - The address tokens will be transferred to\n * @param params.value - The amount of USDC tokens to transfer (in base units)\n * @param params.validAfter - Unix timestamp after which the authorization becomes valid\n * @param params.validBefore - Unix timestamp before which the authorization is valid\n * @param params.nonce - Random 32-byte nonce to prevent replay attacks\n * @param paymentRequirements - The payment requirements containing asset and network information\n * @param paymentRequirements.asset - The address of the USDC contract\n * @param paymentRequirements.network - The network where the USDC contract exists\n * @param paymentRequirements.extra - The extra information containing the name and version of the ERC20 contract\n * @returns The signature for the authorization\n */\nexport async function signAuthorization<transport extends Transport, chain extends Chain>(\n  walletClient: SignerWallet<chain, transport> | Account,\n  { from, to, value, validAfter, validBefore, nonce }: ExactEvmPayloadAuthorization,\n  { asset, network, extra }: PaymentRequirements,\n): Promise<{ signature: Hex }> {\n  const chainId = getNetworkId(network);\n  const name = extra?.name;\n  const version = extra?.version;\n  const account = isSignerWallet(walletClient) ? walletClient.account : walletClient;\n\n  const data = {\n    account,\n    types: authorizationTypes,\n    domain: {\n      name,\n      version,\n      chainId,\n      verifyingContract: asset as Address,\n    },\n    primaryType: \"TransferWithAuthorization\" as const,\n    message: {\n      from,\n      to,\n      value,\n      validAfter,\n      validBefore,\n      nonce: nonce,\n    },\n  };\n\n  if (isSignerWallet(walletClient)) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature,\n    };\n  } else if (isAccount(walletClient) && walletClient.signTypedData) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature,\n    };\n  } else {\n    throw new Error(\"Invalid wallet client provided does not support signTypedData\");\n  }\n}\n\n/**\n * Generates a random 32-byte nonce for use in authorization signatures\n *\n * @returns A random 32-byte nonce as a hex string\n */\nexport function createNonce(): Hex {\n  const cryptoObj =\n    typeof globalThis.crypto !== \"undefined\" &&\n    typeof globalThis.crypto.getRandomValues === \"function\"\n      ? globalThis.crypto\n      : // Dynamic require is needed to support node.js\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        require(\"crypto\").webcrypto;\n  return toHex(cryptoObj.getRandomValues(new Uint8Array(32)));\n}\n","import { Account, Address, Chain, Transport } from \"viem\";\nimport { isSignerWallet, SignerWallet } from \"../../../types/shared/evm\";\nimport { PaymentPayload, PaymentRequirements, UnsignedPaymentPayload } from \"../../../types/verify\";\nimport { createNonce, signAuthorization } from \"./sign\";\nimport { encodePayment } from \"./utils/paymentUtils\";\n\n/**\n * Prepares an unsigned payment header with the given sender address and payment requirements.\n *\n * @param from - The sender's address from which the payment will be made\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns An unsigned payment payload containing authorization details\n */\nexport function preparePaymentHeader(\n  from: Address,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): UnsignedPaymentPayload {\n  const nonce = createNonce();\n\n  const validAfter = BigInt(\n    Math.floor(Date.now() / 1000) - 600, // 10 minutes before\n  ).toString();\n  const validBefore = BigInt(\n    Math.floor(Date.now() / 1000 + paymentRequirements.maxTimeoutSeconds),\n  ).toString();\n\n  return {\n    x402Version,\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    payload: {\n      signature: undefined,\n      authorization: {\n        from,\n        to: paymentRequirements.payTo as Address,\n        value: paymentRequirements.maxAmountRequired,\n        validAfter: validAfter.toString(),\n        validBefore: validBefore.toString(),\n        nonce,\n      },\n    },\n  };\n}\n\n/**\n * Signs a payment header using the provided client and payment requirements.\n *\n * @param client - The signer wallet instance used to sign the payment header\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param unsignedPaymentHeader - The unsigned payment payload to be signed\n * @returns A promise that resolves to the signed payment payload\n */\nexport async function signPaymentHeader<transport extends Transport, chain extends Chain>(\n  client: SignerWallet<chain, transport> | Account,\n  paymentRequirements: PaymentRequirements,\n  unsignedPaymentHeader: UnsignedPaymentPayload,\n): Promise<PaymentPayload> {\n  const { signature } = await signAuthorization(\n    client,\n    unsignedPaymentHeader.payload.authorization,\n    paymentRequirements,\n  );\n\n  return {\n    ...unsignedPaymentHeader,\n    payload: {\n      ...unsignedPaymentHeader.payload,\n      signature,\n    },\n  };\n}\n\n/**\n * Creates a complete payment payload by preparing and signing a payment header.\n *\n * @param client - The signer wallet instance used to create and sign the payment\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the complete signed payment payload\n */\nexport async function createPayment<transport extends Transport, chain extends Chain>(\n  client: SignerWallet<chain, transport> | Account,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<PaymentPayload> {\n  const from = isSignerWallet(client) ? client.account!.address : client.address;\n  const unsignedPaymentHeader = preparePaymentHeader(from, x402Version, paymentRequirements);\n  return signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader);\n}\n\n/**\n * Creates and encodes a payment header for the given client and payment requirements.\n *\n * @param client - The signer wallet instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the encoded payment header string\n */\nexport async function createPaymentHeader(\n  client: SignerWallet | Account,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<string> {\n  const payment = await createPayment(client, x402Version, paymentRequirements);\n  return encodePayment(payment);\n}\n"],"mappings":"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","names":[]}