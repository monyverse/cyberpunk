"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64FromUint8Array = exports.deserializePasskeyValidatorData = exports.serializePasskeyValidatorData = exports.parseAndNormalizeSig = exports.findQuoteIndices = exports.b64ToBytes = exports.hexStringToUint8Array = exports.uint8ArrayToHexString = exports.isRIP7212SupportedNetwork = void 0;
const p256_1 = require("@noble/curves/p256");
const viem_1 = require("viem");
const RIP7212_SUPPORTED_NETWORKS = [80001, 137];
const isRIP7212SupportedNetwork = (chainId) => RIP7212_SUPPORTED_NETWORKS.includes(chainId);
exports.isRIP7212SupportedNetwork = isRIP7212SupportedNetwork;
const uint8ArrayToHexString = (array) => {
    return `0x${Array.from(array, (byte) => byte.toString(16).padStart(2, "0")).join("")}`;
};
exports.uint8ArrayToHexString = uint8ArrayToHexString;
const hexStringToUint8Array = (hexString) => {
    const formattedHexString = hexString.startsWith("0x")
        ? hexString.slice(2)
        : hexString;
    const byteArray = new Uint8Array(formattedHexString.length / 2);
    for (let i = 0; i < formattedHexString.length; i += 2) {
        byteArray[i / 2] = Number.parseInt(formattedHexString.substring(i, i + 2), 16);
    }
    return byteArray;
};
exports.hexStringToUint8Array = hexStringToUint8Array;
const b64ToBytes = (base64) => {
    const paddedBase64 = base64
        .replace(/-/g, "+")
        .replace(/_/g, "/")
        .padEnd(base64.length + ((4 - (base64.length % 4)) % 4), "=");
    const binString = atob(paddedBase64);
    return Uint8Array.from(binString, (m) => m.codePointAt(0) ?? 0);
};
exports.b64ToBytes = b64ToBytes;
const findQuoteIndices = (input) => {
    const beforeTypeIndex = BigInt(input.lastIndexOf('"type":"webauthn.get"'));
    const beforeChallengeIndex = BigInt(input.indexOf('"challenge'));
    return {
        beforeType: beforeTypeIndex,
        beforeChallenge: beforeChallengeIndex
    };
};
exports.findQuoteIndices = findQuoteIndices;
function parseAndNormalizeSig(derSig) {
    const parsedSignature = p256_1.p256.Signature.fromDER(derSig.slice(2));
    const bSig = (0, viem_1.hexToBytes)(`0x${parsedSignature.toCompactHex()}`);
    const bR = bSig.slice(0, 32);
    const bS = bSig.slice(32);
    const r = (0, viem_1.bytesToBigInt)(bR);
    let s = (0, viem_1.bytesToBigInt)(bS);
    const n = BigInt("0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
    if (s > n / 2n) {
        s = n - s;
    }
    return { r, s };
}
exports.parseAndNormalizeSig = parseAndNormalizeSig;
const serializePasskeyValidatorData = (params) => {
    const replacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
    const jsonString = JSON.stringify(params, replacer);
    const uint8Array = new TextEncoder().encode(jsonString);
    const base64String = bytesToBase64(uint8Array);
    return base64String;
};
exports.serializePasskeyValidatorData = serializePasskeyValidatorData;
const deserializePasskeyValidatorData = (params) => {
    const uint8Array = base64ToBytes(params);
    const jsonString = new TextDecoder().decode(uint8Array);
    const parsed = JSON.parse(jsonString);
    return parsed;
};
exports.deserializePasskeyValidatorData = deserializePasskeyValidatorData;
function base64ToBytes(base64) {
    const binString = atob(base64);
    return Uint8Array.from(binString, (m) => m.codePointAt(0));
}
function bytesToBase64(bytes) {
    const binString = Array.from(bytes, (x) => String.fromCodePoint(x)).join("");
    return btoa(binString);
}
const base64FromUint8Array = (uint8Arr, urlMode) => {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    const charsUrl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    let result = "";
    const len = uint8Arr.length;
    const target = urlMode ? charsUrl : chars;
    for (let i = 0; i < len; i += 3) {
        result += target[uint8Arr[i] >> 2];
        result += target[((uint8Arr[i] & 3) << 4) | (uint8Arr[i + 1] >> 4)];
        result += target[((uint8Arr[i + 1] & 15) << 2) | (uint8Arr[i + 2] >> 6)];
        result += target[uint8Arr[i + 2] & 63];
    }
    const remainder = len % 3;
    if (remainder === 2) {
        result = result.substring(0, result.length - 1) + (urlMode ? "" : "=");
    }
    else if (remainder === 1) {
        result = result.substring(0, result.length - 2) + (urlMode ? "" : "==");
    }
    return result;
};
exports.base64FromUint8Array = base64FromUint8Array;
//# sourceMappingURL=utils.js.map